import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../api.mjs";import{SolanaWalletAddress as o,WalletAddress as n}from"../core.mjs";import{PrivateKeyExportInput as r}from"./export.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const s=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let l=t.object({address:o.optional(),chain_type:t.literal("solana").optional()}),d=t.object({address:n.optional(),chain_type:t.literal("ethereum").optional()});const c=t.enum(["root","manager","delegated-actions"]).nullable(),h=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),g=t.object({method:t.literal("signAndSendTransaction"),caip2:s,params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),p=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")})}).merge(l);let m=t.string().startsWith("0x"),_=t.union([m,t.number()]);const b=t.object({from:n.optional(),to:n.optional(),chain_id:_.optional(),nonce:_.optional(),data:m.optional(),value:_.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:_.optional(),gas_price:_.optional(),max_fee_per_gas:_.optional(),max_priority_fee_per_gas:_.optional()}),u=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:b})}).merge(d),y=t.object({method:t.literal("eth_sendTransaction"),caip2:s,params:t.object({transaction:b})}).merge(d),j=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}),z=t.object({method:t.literal("personal_sign"),params:j}).merge(d),f=t.record(t.string(),t.any()),v=t.object({name:t.string(),version:t.string(),chainId:t.number(),verifyingContract:t.string()}).merge(t.object({}).catchall(t.any()));let k=t=>t.replace(/_([a-z])/g,((t,e)=>e.toUpperCase()));const I=t.union([v,f]).transform((t=>{let e={};for(let[i,a]of Object.entries(t))["chain_id","verifying_contract"].includes(i)&&(e[k(i)]=a);return e})),x=t.record(t.array(t.object({name:t.string(),type:t.string()}))),w=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:I,types:x,message:t.record(t.string(),t.any()),primary_type:t.string()})})}).merge(d),A=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:r}),T=t.discriminatedUnion("method",[u,y,z,w]),D=t.discriminatedUnion("method",[h,g,p]),C=t.union([T,D,A]),O=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),P=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),U=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),W=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),K=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),L=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),M=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),N=t.object({method:t.literal("exportPrivateKey"),data:r}),S=t.discriminatedUnion("method",[O,P,U,W,K,L,M,N]),V=t.object({display_name:t.string().optional(),public_key:t.string(),role:c.optional()});let q=t.union([t.literal("solana"),t.literal("ethereum")]);const R=t.object({id:t.string(),address:t.string(),created_at:t.number(),chain_type:q,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2()})),owner_id:t.string().cuid2().nullable()}),Z=t.string().cuid2(),$=t.string(),B=t.object({public_key:$}),E={owner:B.nullable().optional(),owner_id:Z.nullable().optional()},F=t.object({chain_type:q,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2()})).optional(),...E}).refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),G=t.object({id:t.string(),chain_type:q,address:t.string(),authorization_threshold:t.number().optional()}),H=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),J=t.object({id:t.string()}),Q=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:c,created_at:t.number()}),X=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),Y=a.extend({chain_type:q.optional()}),tt=t.object({policy_ids:t.array(t.string()).max(1,"Only one policy ID can be set").optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))}));export{Q as AuthorizationKeyDashboardResponse,X as AuthorizationKeyResponse,c as AuthorizationKeyRole,s as CAIP2,v as CurrentTypedDataDomainInputParams,Z as KeyQuorumId,f as LegacyTypedDataDomainInputParams,B as OwnerInput,E as OwnerInputFields,$ as P256PublicKey,I as TypedDataDomainInputParams,x as TypedDataTypesInputParams,b as UnsignedEthereumTransaction,F as WalletApiCreateInput,G as WalletApiCreateResponse,z as WalletApiEthereumPersonalSignRpcInput,j as WalletApiEthereumPersonalSignRpcInputParams,L as WalletApiEthereumPersonalSignRpcResponse,T as WalletApiEthereumRpcInput,y as WalletApiEthereumSendTransactionRpcInput,K as WalletApiEthereumSendTransactionRpcResponse,u as WalletApiEthereumSignTransactionRpcInput,W as WalletApiEthereumSignTransactionRpcResponse,w as WalletApiEthereumSignTypedDataRpcInput,M as WalletApiEthereumSignTypedDataRpcResponse,A as WalletApiExportPrivateKeyRpcInput,N as WalletApiExportPrivateKeyRpcResponse,V as WalletApiRegisterAuthorizationKeyInput,J as WalletApiRevokeAuthorizationKeyInput,C as WalletApiRpcInput,S as WalletApiRpcResponse,D as WalletApiSolanaRpcInput,g as WalletApiSolanaSignAndSendTransactionRpcInput,P as WalletApiSolanaSignAndSendTransactionRpcResponse,p as WalletApiSolanaSignMessageRpcInput,U as WalletApiSolanaSignMessageRpcResponse,h as WalletApiSolanaSignTransactionRpcInput,O as WalletApiSolanaSignTransactionRpcResponse,H as WalletIdFromPath,R as WalletResponse,tt as WalletUpdateInput,Y as WalletsSearchInput};
