import{u as e,g as i,a as n,b as s,c as l,d as h,C as d,e as m,s as k,P as C,f,h as T,i as W,G as U,W as P,j as R,k as S,l as N,m as O,n as M}from"./privy-provider-Bdp7T8ta.mjs";export{q as Captcha,r as ConnectorManager,E as EthereumWalletConnector,L as LoginModal,B as PrivyClient,o as PrivyProvider,V as VERSION,t as WalletConnector,z as errorIndicatesMaxMfaRetries,A as errorIndicatesMfaTimeout,y as errorIndicatesMfaVerificationFailed,p as getAccessToken,I as useCreateWallet,D as useIdentityToken,K as useImportWallet,F as useLogout,w as useMfa,x as useMfaEnrollment,v as usePrivy,H as useRegisterMfaListener,J as useSolanaWallets}from"./privy-provider-Bdp7T8ta.mjs";import{useCallback as _,useMemo as j,useEffect as G,useContext as Q}from"react";import{u as X,P as $,a as Y,I as Z}from"./internal-context-VSJVgTzy.mjs";export{c as useActiveWallet,a as useConnectWallet,b as useFundWallet,u as useLogin}from"./useActiveWallet-BNKxAK-E.mjs";import{F as ee}from"./frame-Df-urdO7.mjs";import{zeroAddress as te,getAddress as re,createWalletClient as oe,http as ie,parseSignature as ne}from"viem";import{hashAuthorization as ae}from"viem/utils";export{DEFAULT_SUPPORTED_CHAINS as SUPPORTED_CHAINS,addPrivyRpcToChain,addRpcUrlOverrideToChain}from"@privy-io/js-sdk-core";export{g as getEmbeddedConnectedWallet}from"./getEmbeddedConnectedWallet-CSSBWE2p.mjs";import"react/jsx-runtime";import"mipd";import"react-device-detect";import"uuid";import"jose";import"eventemitter3";import"@coinbase/wallet-sdk";import"@marsidev/react-turnstile";import"styled-components";import"tinycolor2";import"@heroicons/react/24/outline/DevicePhoneMobileIcon";import"@heroicons/react/24/outline/FingerPrintIcon";import"@heroicons/react/24/outline/PhoneIcon";import"@heroicons/react/24/outline/ShieldCheckIcon";import"@heroicons/react/24/outline/ArrowLeftIcon";import"@heroicons/react/24/outline/ArrowRightIcon";import"@heroicons/react/24/outline/QuestionMarkCircleIcon";import"@heroicons/react/24/outline/XMarkIcon";import"@heroicons/react/24/outline/ChevronDownIcon";import"@heroicons/react/24/outline/CalendarIcon";import"@heroicons/react/24/outline/ExclamationTriangleIcon";import"@headlessui/react";import"@walletconnect/ethereum-provider";import"zustand";import"fast-password-entropy";import"secure-password-utilities";import"secure-password-utilities/wordlists";import"@heroicons/react/24/outline/UserCircleIcon";import"@heroicons/react/24/outline/EnvelopeIcon";import"@heroicons/react/20/solid/CheckIcon";import"@heroicons/react/24/outline/WalletIcon";import"@heroicons/react/24/outline/CheckIcon";import"@heroicons/react/24/outline/Square2StackIcon";import"@heroicons/react/24/outline/ExclamationCircleIcon";import"@heroicons/react/24/outline/ArrowTopRightOnSquareIcon";import"@heroicons/react/24/solid/DocumentCheckIcon";import"@heroicons/react/24/solid/XCircleIcon";import"@heroicons/react/24/solid/CheckCircleIcon";import"qrcode";import"@heroicons/react/24/outline/ChevronRightIcon";import"@heroicons/react/24/outline/LockClosedIcon";import"@heroicons/react/24/outline/PencilSquareIcon";import"@heroicons/react/24/outline/ArrowPathIcon";import"@heroicons/react/24/outline/EyeIcon";import"@heroicons/react/24/outline/EyeSlashIcon";import"@heroicons/react/24/outline/KeyIcon";import"@heroicons/react/24/outline/ArrowDownTrayIcon";import"@heroicons/react/24/outline/ClipboardDocumentCheckIcon";import"@heroicons/react/24/outline/DocumentDuplicateIcon";import"@heroicons/react/24/solid/LockClosedIcon";import"@heroicons/react/24/outline/CheckCircleIcon";import"@heroicons/react/24/outline/InformationCircleIcon";import"@heroicons/react/24/outline/CreditCardIcon";import"@heroicons/react/24/outline/QrCodeIcon";import"@heroicons/react/24/solid/ArrowsRightLeftIcon";import"@heroicons/react/24/outline/GlobeAltIcon";import"@solana/web3.js";import"ofetch";import"@heroicons/react/24/outline";import"@heroicons/react/24/outline/ClipboardDocumentIcon";import"@heroicons/react/24/outline/CloudArrowUpIcon";import"@heroicons/react/24/outline/NoSymbolIcon";import"@heroicons/react/24/outline/ClockIcon";import"@heroicons/react/24/outline/TrashIcon";import"@heroicons/react/24/solid/CheckBadgeIcon";import"@heroicons/react/24/solid/IdentificationIcon";import"@heroicons/react/24/outline/MinusCircleIcon";import"@heroicons/react/24/outline/ArrowRightEndOnRectangleIcon";import"@heroicons/react/24/solid/ShieldCheckIcon";import"js-cookie";const se=()=>{let{user:t}=e(),{walletProxy:r}=X();return{recover:_((async e=>{if(!r)throw Error("Wallet proxy is not ready");let o=await i();if(!t||!o)throw new $("User must be logged in before attempting to modify the recovery method.");let{entropyId:a,entropyIdVerifier:s}=n(t);try{await r.recover({entropyId:a,entropyIdVerifier:s,accessToken:o,...e})}catch{throw new $("Unable to recover wallets")}}),[r,t])}},ce=()=>{let{client:e,setAuthenticated:t,setUser:r}=X();return j((()=>({init:async()=>{if(!e)throw new $("Must initialize Privy client first.");let t=new ee;return e.startAuthFlow(t),await t.init()},login:async({fid:o,message:i,signature:n})=>{if(!e)throw new $("Must initialize Privy client first.");if(!(e.authFlow instanceof ee))throw new $("Must initialize Farcaster frame flow first.");e.authFlow.setAuthData({message:i,signature:n,fid:o});let{user:a}=await e.authenticate();if(!a)throw new $("Failed to login with Farcaster V2");return r(a),t(!0),{user:a}}})),[e,r,t])},le=t=>{s("login",t);let r=l(),o=h(),{ready:i,user:n}=e(),{initLoginWithHeadlessOAuth:a,loginWithHeadlessOAuth:c,oAuthState:u,setOAuthState:p,isHeadlessOAuthLoading:w}=X(),g=_((async e=>{try{if(r.enabled&&"success"!==r.status)throw new d(r.error,null,Y.CAPTCHA_FAILURE);return await a(e.provider,r.token,e.disableSignup)}catch(e){throw p({status:"error",error:e}),e}}),[a,r]),y=_((async()=>{let e=m();try{if(n)return console.warn("Cannot login with OAuth when already logged in"),n;if(!e.inProgress)throw Error("Cannot login with OAuth because no OAuth flow is in progress");if(e.popupFlow)return}catch(e){throw p({status:"error",error:e}),e}try{return await c(e)}catch(e){throw p({status:"error",error:e}),e}finally{k()}}),[c]);return G((()=>{let e=m();i&&o&&e.inProgress&&!e.withPrivyUi&&!e.popupFlow&&y().catch((()=>{}))}),[i,o]),{initOAuth:g,loading:w,state:u}},ue=e=>{let t=l(),{emailOtpState:r,setEmailOtpState:o,initLoginWithEmail:i,loginWithCode:n}=X();return{sendCode:_((async({email:r,disableSignup:n})=>{try{let e;if(!r)throw Error("Email required to send OTP code");if(t.enabled&&"error"===t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({email:r,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),r}}),[i]),loginWithCode:_((async({code:r})=>{try{if(t.enabled&&"error"===t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:s}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"email",loginAccount:s})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},he=e=>{let t=l(),{initSignupWithPasskey:r,signupWithPasskey:o,passkeyAuthState:i,setPasskeyAuthState:n}=X();return{signupWithPasskey:_((async()=>{try{let i;if(t.enabled&&"error"===t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),i=await t.waitForResult()),await r({captchaToken:i,withPrivyUi:!1});let{user:n,isNewUser:a,wasAlreadyAuthenticated:s,loginAccount:c}=await o();e?.onComplete?.({user:n,isNewUser:a,wasAlreadyAuthenticated:s,loginMethod:"passkey",loginAccount:c})}catch(t){throw n({status:"error",error:t}),e?.onError?.(t.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),t}}),[o,t.status]),state:i}},de=e=>{let t=l(),{initLoginWithPasskey:r,loginWithPasskey:o,passkeyAuthState:i,setPasskeyAuthState:n}=X();return{loginWithPasskey:_((async i=>{try{let n;if(t.enabled&&"error"===t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);t.enabled&&"success"!==t.status&&(t.execute(),n=await t.waitForResult()),await r({captchaToken:n,withPrivyUi:!1});let{user:a,isNewUser:s,wasAlreadyAuthenticated:c,loginAccount:l}=await o(i);e?.onComplete?.({user:a,isNewUser:s,wasAlreadyAuthenticated:c,loginMethod:"passkey",loginAccount:l})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),i}}),[o,t.status]),state:i}},pe=e=>{let{initLinkWithPasskey:t,linkWithPasskey:r,passkeyAuthState:o,setPasskeyAuthState:i}=X();return{linkWithPasskey:_((async()=>{try{await t();let o=await r();if(!o)throw Error("Error, user not found");let i=o.linkedAccounts.filter((e=>"passkey"===e.type)).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0];e?.onSuccess?.({user:o,linkMethod:"passkey",linkedAccount:i})}catch(t){throw i({status:"error",error:t}),e?.onError?.(t.privyErrorCode||Y.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),t}}),[r]),state:o}},we=e=>{let t=l(),{smsOtpState:r,setSmsOtpState:o,initLoginWithSms:i,loginWithCode:n}=X();return{sendCode:_((async({phoneNumber:r,disableSignup:n})=>{try{let e;if(!r)throw Error("SMS required to send OTP code");if(t.enabled&&"error"===t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);return t.enabled&&"success"!==t.status&&(t.execute(),e=await t.waitForResult()),await i({phoneNumber:r,captchaToken:e,disableSignup:n,withPrivyUi:!1})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),r}}),[i]),loginWithCode:_((async({code:r})=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);let{user:o,isNewUser:i,wasAlreadyAuthenticated:a,linkedAccount:s}=await n(r);e?.onComplete?.({user:o,isNewUser:i,wasAlreadyAuthenticated:a,loginMethod:"sms",loginAccount:s})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),r}}),[n,t.status]),state:r}},me=t=>{let{connectOrCreateWallet:r}=e();return s("connectOrCreateWallet",t),{connectOrCreateWallet:r}},ge=e=>{let t=l(),{siweState:r,setSiweState:o,linkWithSiwe:i,generateSiweMessage:n}=X();return{generateSiweMessage:_((async({address:t,chainId:r})=>{try{if(!t||!r)throw Error("wallet address and chainId required to generate nonce");return await n({address:t,chainId:r}).then((e=>e))}catch(t){throw o({status:"error",error:t}),e?.onError?.(t.privyErrorCode||Y.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),t}}),[n]),linkWithSiwe:_((async({signature:r,message:n,chainId:a,walletClientType:s,connectorType:c})=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);let{user:o,linkedAccount:l}=await i({message:n,signature:r,chainId:a,walletClientType:s,connectorType:c});l&&e?.onSuccess?.({user:o,linkMethod:"siwe",linkedAccount:l})}catch(r){throw o({status:"error",error:r}),e?.onError?.(r.privyErrorCode||Y.UNKNOWN_AUTH_ERROR,{linkMethod:"siwe"}),r}}),[i,t.status]),state:r}};function ye(){let{signTransaction:e}=Q(C);return{signTransaction:e}}function Ae(e){let{linkEmail:t,linkPhone:r,linkWallet:o,linkGoogle:i,linkApple:n,linkTwitter:a,linkDiscord:c,linkGithub:l,linkLinkedIn:u,linkTiktok:h,linkSpotify:d,linkInstagram:p,linkTelegram:w,linkFarcaster:m}=Q(C);return s("linkAccount",e),{linkEmail:t,linkPhone:r,linkWallet:o,linkGoogle:i,linkApple:n,linkTwitter:a,linkDiscord:c,linkGithub:l,linkLinkedIn:u,linkTiktok:h,linkSpotify:d,linkInstagram:p,linkFarcaster:m,linkTelegram:w}}function ke(e){let{updateEmail:t,updatePhone:r}=Q(C);return s("update",e),{updateEmail:t,updatePhone:r}}const Ce=()=>{let{connectCoinbaseSmartWallet:e}=X();return{connectCoinbaseSmartWallet:e}},fe=()=>{let{startCrossAppAuthFlow:t,unlinkCrossAppAccount:r,signMessageWithCrossAppWallet:o,signTypedDataWithCrossAppWallet:i,sendTransactionWithCrossAppWallet:n}=e();return{loginWithCrossAppAccount:({appId:e})=>t({appId:e,action:"login"}),linkCrossAppAccount:({appId:e})=>t({appId:e,action:"link"}),unlinkCrossAppAccount:r,signMessage:o,signTypedData:i,sendTransaction:n}};function Ie(e){let{sendTransaction:t}=Q(C);return s("sendTransaction",e),{sendTransaction:t}}function Te(e){let{setWalletPassword:t}=Q(C);return s("setWalletPassword",e),{setWalletPassword:t}}function Ee(){let t=f(),{getAccessToken:r}=e(),o=T(),{client:i,setUser:n,setAuthenticated:a,setIsNewUser:s,initializeWalletProxy:c}=X(),{create:l}=W();return{createGuestAccount:async()=>{if(!t.id||!i)throw Error("SDK not yet ready");i.startAuthFlow(new U(t.id));try{let e=await i.authenticate(),u=e.user,h=e.isNewUser??!1;if(!u)throw new $("Unable to authenticate guest account");let d=await r(),p=await c(P);if(d&&p)try{let e=R(u,t.embeddedWallets.ethereum.createOnLogin),r=S(u,t.embeddedWallets.solana.createOnLogin);e&&r?(u=(await l({chainType:"ethereum",latestUser:u})).user,u=(await l({chainType:"solana",latestUser:u})).user):r?u=(await l({chainType:"solana",latestUser:u})).user:e?u=(await l({chainType:"ethereum",latestUser:u})).user:n(u)}catch(e){n(u),console.warn("Unable to create embedded wallet for guest account")}return s(h),a(!0),o("login","onComplete",{user:u,isNewUser:h,wasAlreadyAuthenticated:!1,loginMethod:"guest",loginAccount:null}),u}catch(e){throw o("login","onError",e.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),e}}}}function We(e){let{setWalletRecovery:t}=Q(C);return s("setWalletRecovery",e),{setWalletRecovery:t}}function Ue(e){let{signMessage:t}=Q(C);return s("signMessage",e),{signMessage:t}}const Pe=()=>{let{ready:t,wallets:r}=N(),{user:o}=e(),{rpcConfig:i,chains:n,appId:a}=X();return{signAuthorization:_((async(e,s)=>{if(!o)throw Error("User must be authenticated before signing with a Privy wallet");if(!t)throw Error("Wallets are not ready");let c=s?.address??O(o)?.address??te,l=r.find((e=>re(e.address)===re(c)));if(!l)throw Error("Signing wallet not found.");let u=e.chainId??Number(l.chainId.split(":")[1]),h=n.find((e=>e.id===u));if(!h)throw Error("Error, chain not configured in PrivyProvider config");let d=oe({account:c,chain:h,transport:ie(M(h,i,a))}),p=await d.prepareAuthorization({...e}),w=await l.getEthereumProvider(),m=await w.request({method:"secp256k1_sign",params:[ae(p)]});return{...p,...ne(m)}}),[t,r,o,n])}};function Re(e){let{signTypedData:t}=Q(C);return s("signTypedData",e),{signTypedData:t}}const Se=()=>{let{isModalOpen:e}=Q(C);return{isOpen:e}};function ve(e){let{getAccessToken:t}=Q(C);return s("accessToken",e),{getAccessToken:t}}function Ne(t){let{authenticated:r,user:o}=e(),{initLoginWithOAuth:i}=X(),n=T();return s("oAuthAuthorization",t),{reauthorize:e=>be(r,o,i,n,e.provider)}}let be=async(e,t,r,o,i)=>{if(!e)throw o("linkAccount","onError",Y.MUST_BE_AUTHENTICATED,{linkMethod:i}),new $("User must be authenticated before linking an account.");if(!t?.linkedAccounts.some((e=>e.type.includes(i))))throw new $(`OAuth account of type ${i} not linked to the account.`);await r(i)};const Oe=e=>{let{customAuthStatus:t}=X();return s("customAuth",e),{status:t}};function Me(){let{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}=e();return{getFarcasterSignerPublicKey:t,signFarcasterMessage:r,requestFarcasterSignerFromWarpcast:o}}const Fe=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=X();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!0}),revokeWallets:async()=>await e({showDelegationUIs:!0})}},_e=()=>{let{setUser:e,client:t}=Q(Z),{user:r}=Q(C);return{user:r,refreshUser:_((async()=>{let r=await(t?.updateUserAndIdToken());return e(r??null),r}),[t,e])}},Le=e=>{let t=l(),{initLoginWithTelegram:r,loginWithTelegram:o,telegramAuthState:i,setTelegramAuthState:n}=X();return{login:_((async i=>{try{if(t.enabled&&"success"!==t.status)throw new d(t.error,null,Y.CAPTCHA_FAILURE);await r(t.token,i?.disableSignup);let{user:n,isNewUser:a,loginAccount:s,wasAlreadyAuthenticated:c}=await o({intent:"login"});e?.onComplete?.({user:n,isNewUser:a,wasAlreadyAuthenticated:c,loginMethod:"telegram",loginAccount:s})}catch(i){throw n({status:"error",error:i}),e?.onError?.(i.privyErrorCode||Y.UNKNOWN_AUTH_ERROR),i}}),[r,o,t]),state:i}},De=()=>{let{revokeDelegatedWallets:e,delegateWallet:t}=X();return{delegateWallet:async({address:e,chainType:r})=>await t({address:e,chainType:r,showDelegationUIs:!1}),revokeWallets:async()=>await e({showDelegationUIs:!1})}};export{Ce as useConnectCoinbaseSmartWallet,me as useConnectOrCreateWallet,fe as useCrossAppAccounts,Oe as useCustomAuth,Fe as useDelegatedActions,Me as useFarcasterSigner,Ee as useGuestAccounts,De as useHeadlessDelegatedActions,Ae as useLinkAccount,pe as useLinkWithPasskey,ge as useLinkWithSiwe,ue as useLoginWithEmail,ce as useLoginWithFarcasterV2,le as useLoginWithOAuth,de as useLoginWithPasskey,we as useLoginWithSms,Le as useLoginWithTelegram,Se as useModalStatus,Ne as useOAuthTokens,se as useRecoverEmbeddedWallet,Ie as useSendTransaction,Te as useSetWalletPassword,We as useSetWalletRecovery,Pe as useSignAuthorization,Ue as useSignMessage,ye as useSignTransaction,Re as useSignTypedData,he as useSignupWithPasskey,ve as useToken,ke as useUpdateAccount,_e as useUser,N as useWallets};
